-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Query exposing (..)

import Api.Enum.LocationCategory
import Api.Enum.ResourceResource
import Api.Enum.ResourceSize
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias ItemsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , category : OptionalArgument String
    , slot : OptionalArgument String
    , class : OptionalArgument String
    , droppedById : OptionalArgument Api.ScalarCodecs.Id
    , startsQuestId : OptionalArgument Api.ScalarCodecs.Id
    , rewardFromQuestId : OptionalArgument Api.ScalarCodecs.Id
    , stats : OptionalArgument (List Api.InputObject.StatInputFilter)
    , requiredLevel : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    , weight : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    }


items :
    (ItemsOptionalArguments -> ItemsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Item
    -> SelectionSet (List decodesTo) RootQuery
items fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, category = Absent, slot = Absent, class = Absent, droppedById = Absent, startsQuestId = Absent, rewardFromQuestId = Absent, stats = Absent, requiredLevel = Absent, weight = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "category" filledInOptionals____.category Encode.string, Argument.optional "slot" filledInOptionals____.slot Encode.string, Argument.optional "class" filledInOptionals____.class Encode.string, Argument.optional "droppedById" filledInOptionals____.droppedById (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "startsQuestId" filledInOptionals____.startsQuestId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "rewardFromQuestId" filledInOptionals____.rewardFromQuestId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "stats" filledInOptionals____.stats (Api.InputObject.encodeStatInputFilter |> Encode.list), Argument.optional "requiredLevel" filledInOptionals____.requiredLevel (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list), Argument.optional "weight" filledInOptionals____.weight (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "items" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias LocationsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , zoneId : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , category : OptionalArgument Api.Enum.LocationCategory.LocationCategory
    }


{-|

  - zoneId - Zone ID the Location must be in

-}
locations :
    (LocationsOptionalArguments -> LocationsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Location
    -> SelectionSet (List decodesTo) RootQuery
locations fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, zoneId = Absent, name = Absent, category = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "zoneId" filledInOptionals____.zoneId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "category" filledInOptionals____.category (Encode.enum Api.Enum.LocationCategory.toString) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "locations" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MonstersOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , elite : OptionalArgument Bool
    , named : OptionalArgument Bool
    , dropsId : OptionalArgument Api.ScalarCodecs.Id
    , locationId : OptionalArgument Api.ScalarCodecs.Id
    , zoneId : OptionalArgument Api.ScalarCodecs.Id
    , level : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    }


{-|

  - dropsId - Item ID of something the monster drops
  - locationId - Location ID the monster must be in
  - zoneId - Zone ID the monster must be in

-}
monsters :
    (MonstersOptionalArguments -> MonstersOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Monster
    -> SelectionSet (List decodesTo) RootQuery
monsters fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, elite = Absent, named = Absent, dropsId = Absent, locationId = Absent, zoneId = Absent, level = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "elite" filledInOptionals____.elite Encode.bool, Argument.optional "named" filledInOptionals____.named Encode.bool, Argument.optional "dropsId" filledInOptionals____.dropsId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "locationId" filledInOptionals____.locationId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "zoneId" filledInOptionals____.zoneId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "level" filledInOptionals____.level (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "monsters" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpcsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , subtitle : OptionalArgument String
    , vendor : OptionalArgument Bool
    , locationId : OptionalArgument Api.ScalarCodecs.Id
    , zoneId : OptionalArgument Api.ScalarCodecs.Id
    , givesQuestId : OptionalArgument Api.ScalarCodecs.Id
    , receivesQuestId : OptionalArgument Api.ScalarCodecs.Id
    , sellsItemId : OptionalArgument Api.ScalarCodecs.Id
    }


{-|

  - locationId - Location ID the Npc must be in

-}
npcs :
    (NpcsOptionalArguments -> NpcsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Npc
    -> SelectionSet (List decodesTo) RootQuery
npcs fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, subtitle = Absent, vendor = Absent, locationId = Absent, zoneId = Absent, givesQuestId = Absent, receivesQuestId = Absent, sellsItemId = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "subtitle" filledInOptionals____.subtitle Encode.string, Argument.optional "vendor" filledInOptionals____.vendor Encode.bool, Argument.optional "locationId" filledInOptionals____.locationId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "zoneId" filledInOptionals____.zoneId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "givesQuestId" filledInOptionals____.givesQuestId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "receivesQuestId" filledInOptionals____.receivesQuestId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "sellsItemId" filledInOptionals____.sellsItemId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "npcs" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestObjectivesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id }


questObjectives :
    (QuestObjectivesOptionalArguments -> QuestObjectivesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.QuestObjective
    -> SelectionSet (List decodesTo) RootQuery
questObjectives fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "questObjectives" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestRewardsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id }


questRewards :
    (QuestRewardsOptionalArguments -> QuestRewardsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.QuestReward
    -> SelectionSet (List decodesTo) RootQuery
questRewards fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "questRewards" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , text : OptionalArgument String
    , giverId : OptionalArgument Api.ScalarCodecs.Id
    , receiverId : OptionalArgument Api.ScalarCodecs.Id
    , prereqQuestId : OptionalArgument Api.ScalarCodecs.Id
    }


quests :
    (QuestsOptionalArguments -> QuestsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Quest
    -> SelectionSet (List decodesTo) RootQuery
quests fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, text = Absent, giverId = Absent, receiverId = Absent, prereqQuestId = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "text" filledInOptionals____.text Encode.string, Argument.optional "giverId" filledInOptionals____.giverId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "receiverId" filledInOptionals____.receiverId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "prereqQuestId" filledInOptionals____.prereqQuestId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "quests" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ResourcesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , resource : OptionalArgument (List Api.Enum.ResourceResource.ResourceResource)
    , size : OptionalArgument (List Api.Enum.ResourceSize.ResourceSize)
    }


{-|

  - id - Filter to the given Resource ID

  - name - Filter to matching Resource name

  - resource - Filter to any matching Resource types

  - size - Filter to any matching Resource sizes

-}
resources :
    (ResourcesOptionalArguments -> ResourcesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Resource
    -> SelectionSet (List decodesTo) RootQuery
resources fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, resource = Absent, size = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "resource" filledInOptionals____.resource (Encode.enum Api.Enum.ResourceResource.toString |> Encode.list), Argument.optional "size" filledInOptionals____.size (Encode.enum Api.Enum.ResourceSize.toString |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "resources" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ZonesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-|

  - id - Filter to the given Zone ID
  - name - Filter to matching Zone names

-}
zones :
    (ZonesOptionalArguments -> ZonesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Zone
    -> SelectionSet (List decodesTo) RootQuery
zones fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "zones" optionalArgs____ object____ (Basics.identity >> Decode.list)
