-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Query exposing (..)

import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DungeonsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-|

  - id - Filter to the given Dungeon ID
  - name - Filter to matching Dungeon names

-}
dungeons :
    (DungeonsOptionalArguments -> DungeonsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Dungeon
    -> SelectionSet (List decodesTo) RootQuery
dungeons fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "dungeons" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ItemsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , category : OptionalArgument String
    , slot : OptionalArgument String
    , class : OptionalArgument String
    , droppedBy : OptionalArgument Api.ScalarCodecs.Id
    , startsQuest : OptionalArgument Api.ScalarCodecs.Id
    , rewardFromQuest : OptionalArgument Api.ScalarCodecs.Id
    , stats : OptionalArgument (List Api.InputObject.StatInputFilter)
    , requiredLevel : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    , weight : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    }


items :
    (ItemsOptionalArguments -> ItemsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Item
    -> SelectionSet (List decodesTo) RootQuery
items fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, category = Absent, slot = Absent, class = Absent, droppedBy = Absent, startsQuest = Absent, rewardFromQuest = Absent, stats = Absent, requiredLevel = Absent, weight = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "category" filledInOptionals____.category Encode.string, Argument.optional "slot" filledInOptionals____.slot Encode.string, Argument.optional "class" filledInOptionals____.class Encode.string, Argument.optional "droppedBy" filledInOptionals____.droppedBy (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "startsQuest" filledInOptionals____.startsQuest (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "rewardFromQuest" filledInOptionals____.rewardFromQuest (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "stats" filledInOptionals____.stats (Api.InputObject.encodeStatInputFilter |> Encode.list), Argument.optional "requiredLevel" filledInOptionals____.requiredLevel (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list), Argument.optional "weight" filledInOptionals____.weight (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "items" optionalArgs____ object____ (Basics.identity >> Decode.list)


locations :
    SelectionSet decodesTo Api.Object.Location
    -> SelectionSet (List decodesTo) RootQuery
locations object____ =
    Object.selectionForCompositeField "locations" [] object____ (Basics.identity >> Decode.list)


type alias MonstersOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , elite : OptionalArgument Bool
    , named : OptionalArgument Bool
    , drops : OptionalArgument Api.ScalarCodecs.Id
    , locationId : OptionalArgument Api.ScalarCodecs.Id
    , zoneId : OptionalArgument Api.ScalarCodecs.Id
    , level : OptionalArgument (List Api.InputObject.FloatOperatorInputFilter)
    }


{-|

  - drops - Item ID of something the monster drops
  - locationId - Location ID the monster must be in
  - zoneId - Zone ID the monster must be in

-}
monsters :
    (MonstersOptionalArguments -> MonstersOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Monster
    -> SelectionSet (List decodesTo) RootQuery
monsters fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, elite = Absent, named = Absent, drops = Absent, locationId = Absent, zoneId = Absent, level = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "elite" filledInOptionals____.elite Encode.bool, Argument.optional "named" filledInOptionals____.named Encode.bool, Argument.optional "drops" filledInOptionals____.drops (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "locationId" filledInOptionals____.locationId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "zoneId" filledInOptionals____.zoneId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "level" filledInOptionals____.level (Api.InputObject.encodeFloatOperatorInputFilter |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "monsters" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpcsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    , subtitle : OptionalArgument String
    , vendor : OptionalArgument Bool
    , locationId : OptionalArgument Api.ScalarCodecs.Id
    , zoneId : OptionalArgument Api.ScalarCodecs.Id
    , givesQuest : OptionalArgument Api.ScalarCodecs.Id
    , receivesQuest : OptionalArgument Api.ScalarCodecs.Id
    , sellsItem : OptionalArgument Api.ScalarCodecs.Id
    }


{-|

  - locationId - Location ID the Npc must be in

-}
npcs :
    (NpcsOptionalArguments -> NpcsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Npc
    -> SelectionSet (List decodesTo) RootQuery
npcs fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, subtitle = Absent, vendor = Absent, locationId = Absent, zoneId = Absent, givesQuest = Absent, receivesQuest = Absent, sellsItem = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "subtitle" filledInOptionals____.subtitle Encode.string, Argument.optional "vendor" filledInOptionals____.vendor Encode.bool, Argument.optional "locationId" filledInOptionals____.locationId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "zoneId" filledInOptionals____.zoneId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "givesQuest" filledInOptionals____.givesQuest (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "receivesQuest" filledInOptionals____.receivesQuest (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "sellsItem" filledInOptionals____.sellsItem (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "npcs" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestObjectivesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id }


questObjectives :
    (QuestObjectivesOptionalArguments -> QuestObjectivesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.QuestObjective
    -> SelectionSet (List decodesTo) RootQuery
questObjectives fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "questObjectives" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestRewardsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id }


questRewards :
    (QuestRewardsOptionalArguments -> QuestRewardsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.QuestReward
    -> SelectionSet (List decodesTo) RootQuery
questRewards fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "questRewards" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias QuestsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id }


quests :
    (QuestsOptionalArguments -> QuestsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Quest
    -> SelectionSet (List decodesTo) RootQuery
quests fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "quests" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ResourcesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-|

  - id - Filter to the given Resource ID
  - name - Filter to matching Resource names

-}
resources :
    (ResourcesOptionalArguments -> ResourcesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Resource
    -> SelectionSet (List decodesTo) RootQuery
resources fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "resources" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias SettlementsOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-|

  - name - Filter to matching Settlement names

-}
settlements :
    (SettlementsOptionalArguments -> SettlementsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Settlement
    -> SelectionSet (List decodesTo) RootQuery
settlements fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "settlements" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ZonesOptionalArguments =
    { id : OptionalArgument Api.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-|

  - id - Filter to the given Zone ID
  - name - Filter to matching Zone names

-}
zones :
    (ZonesOptionalArguments -> ZonesOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Zone
    -> SelectionSet (List decodesTo) RootQuery
zones fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "name" filledInOptionals____.name Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "zones" optionalArgs____ object____ (Basics.identity >> Decode.list)
